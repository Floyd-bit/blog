> 闭包是指有权访问另一个函数作用域中变量的函数

### 1. 创建闭包

创建闭包最常见的方式是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量

### 2. 闭包作用

- 通过闭包创建**私有变量**
- 使已经结束的函数上下文中的变量对象继续留在内存中，但容易造成内存泄漏

### 3. 面试题

```js
// 闭包
for (var i=0; i<5; i++) {
    (function(i) {
        setTimeout(() => {
            console.log(i);
        }, 1000)
    })(i); 
}
// setTimeout第三个参数会传入回调函数
for (var i=0; i<5; i++) {
    setTimeout((j) => {
        console.log(j);
    }, 1000, i)
}
// 块级作用域
for (let i=0 ;i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}
```

### 4. 执行上下文

![image-20220423133925178](https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041453509.png)

![](https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041453510.png)

> 执行上下文包含当前执行环境中的变量对象、作用域链、this, 并且分为全局执行上下文和函数执行上下文

- **变量对象存储了上下文中定义的变量和函数声明**，全局执行上下文变量对象是全局对象window，函数执行上下文变量对象就是活动对象

- 在创建执行上下文时，会建立作用域链，作用域是规定了js引擎该如何访问变量的规则。在访问变量时，若在当前作用域(变量对象)上找不到对应变量，则在它的父级作用域进行查找。[[Scopes]]在函数预编译阶段，将父级作用域的[[Scopes]]和自己的函数AO(活动对象)赋值给自己的[[Scopes]]

- this指向当前变量对象

- V8引擎新增了Closure（闭包）,在函数预编译阶段扫描内部函数，如果内部函数引用外层函数中的AO，则将变量添加到Closure中。

  如果函数存在闭包，其所有内部函数都会拥有一个指向这个闭包的引用，即所有内部函数会共享同一个闭包，只要任意内部函数有引用外部函数中声明的变量，这个变量都会被纳入闭包内，而且最内部的函数会持有所有外部的闭包

JavaScript引擎使用**执行上下文栈**来管理执行上下文

当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

### 5. 内存泄漏

- 引发内存泄漏的原因：闭包对象Closure无法被释放。当**所有引用Closure的子函数都被销毁**，Closure才会被销毁
  
  ```javascript
  function fun() {
      let arr = Array(100);
      function fun1() {
          // arr加入Closure
          console.log(arr);
      }
      return function fun2() {}
  }
  // fun2不会被销毁，造成内存泄漏
  window.f = fun2();
  ```
