(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{680:function(_,v,t){"use strict";t.r(v);var s=t(11),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041456973.webp",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"_1-浏览器渲染过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器渲染过程"}},[_._v("#")]),_._v(" 1. 浏览器渲染过程")]),_._v(" "),t("ol",[t("li",[_._v("首先解析收到的文档，根据文档定义构建一棵 "),t("strong",[_._v("DOM 树")]),_._v("，DOM 树是由 DOM 元素及属性节点组成的。")]),_._v(" "),t("li",[_._v("然后对 CSS 进行解析，生成 "),t("strong",[_._v("CSSOM 规则树")]),_._v("。")]),_._v(" "),t("li",[_._v("根据 DOM 树和 CSSOM 规则树构建"),t("strong",[_._v("渲染树(render tree)")]),_._v("。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素("),t("strong",[_._v("meta标签、script标签，display:none的元素")]),_._v(")不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。")]),_._v(" "),t("li",[_._v("当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行"),t("strong",[_._v("布局(Layout)")]),_._v("（也可以叫做"),t("strong",[_._v("回流")]),_._v("）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切"),t("strong",[_._v("位置和大小(几何信息)")]),_._v("。通常这一行为也被称为“自动重排”。")]),_._v(" "),t("li",[_._v("布局阶段结束后是**绘制(paint)**阶段，根据渲染树和回流得到的几何信息，计算出每个节点的绝对像素")]),_._v(" "),t("li",[_._v("展示(Display): 将像素发送给GPU，展示在页面上")])]),_._v(" "),t("h3",{attrs:{id:"_2-触发回流重绘的操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-触发回流重绘的操作"}},[_._v("#")]),_._v(" 2. 触发回流重绘的操作")]),_._v(" "),t("blockquote",[t("p",[_._v("回流一定会触发重绘，而重绘不一定会回流")])]),_._v(" "),t("p",[t("strong",[_._v("回流：")])]),_._v(" "),t("ul",[t("li",[_._v("添加或删除可见的DOM元素")]),_._v(" "),t("li",[_._v("元素的位置发生变化")]),_._v(" "),t("li",[_._v("元素的尺寸发生变化")]),_._v(" "),t("li",[_._v("浏览器的窗口尺寸变化")])]),_._v(" "),t("h3",{attrs:{id:"_3-减少回流和重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-减少回流和重绘"}},[_._v("#")]),_._v(" 3. 减少回流和重绘")]),_._v(" "),t("ul",[t("li",[_._v("使经常修改的DOM元素"),t("strong",[_._v("脱离文档流")]),_._v("，不影响其他元素")]),_._v(" "),t("li",[_._v("最小化重绘和重排，样式集中改变")]),_._v(" "),t("li",[_._v("ccs3硬件加速(GPU加速)，使得动画不会引起回流重绘")]),_._v(" "),t("li",[_._v("不要使用table布局，因为一个小的改动会造成整个table的重新布局")]),_._v(" "),t("li",[_._v("批量添加DOM时，使用文档碎片DocumentFragment")])]),_._v(" "),t("h3",{attrs:{id:"_4-分层和合成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-分层和合成"}},[_._v("#")]),_._v(" 4. 分层和合成")]),_._v(" "),t("p",[t("code",[_._v("光栅化(rasterizing)")]),_._v(": 将元素的几何信息、样式信息、绘画顺序转化为显示器中的像素")]),_._v(" "),t("p",[t("code",[_._v("动画的渲染")]),_._v("：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("只光栅化视口(viewport)内的网页内容，滚动网页时移动光栅帧并且光栅更多的内容以补上页面缺失的部分")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041456974.png",alt:""}})])]),_._v(" "),t("li",[t("p",[_._v("利用分层和合成的技术，将页面各个层光栅化，滚动网页时只需要将页面上的层进行移动并构建成新的一帧")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041456975.png",alt:""}})])])]),_._v(" "),t("p",[_._v("在实现一些复杂的动画效果时，如果采用js实现，每次页面发生改变都会触发重排或者重绘机制，影响页面的渲染效率")]),_._v(" "),t("p",[_._v("使用css动画实现，利用GPU实现分层和合成。类似于ps，可以把一张网页当成多个图片叠加在一起，将一个页面分为多层，这样在更新页面时只需要在相应层上进行变化，最后再合成。")]),_._v(" "),t("h3",{attrs:{id:"_5-页面渲染技术架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-页面渲染技术架构"}},[_._v("#")]),_._v(" 5. 页面渲染技术架构")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("服务端渲染")]),_._v(" "),t("p",[_._v("后端同步渲染(jsp、php)、同构直出(node.js)")]),_._v(" "),t("p",[t("strong",[_._v("JSP同步渲染流程")]),_._v("：")]),_._v(" "),t("p",[_._v(".jsp文件请求时，对应的JSP Servlet进行编译并发送给客户端浏览器HTML")]),_._v(" "),t("p",[_._v("缺点：渲染耗时长，用户需等待HTML完全加载后才能看到页面内容；代码耦合严重，业务逻辑和页面模板耦合在一起")])]),_._v(" "),t("li",[t("p",[_._v("客户端渲染")]),_._v(" "),t("ul",[t("li",[_._v("JS渲染：SPA")]),_._v(" "),t("li",[_._v("Web APP: Angular、React、Vue, PWA")]),_._v(" "),t("li",[_._v("原生APP：IOS、Android")]),_._v(" "),t("li",[_._v("Hybrid APP: PhoneGap")]),_._v(" "),t("li",[_._v("跨平台开发：React Native、Flutter、小程序")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);