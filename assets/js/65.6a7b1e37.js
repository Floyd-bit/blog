(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{664:function(v,_,t){"use strict";t.r(_);var o=t(11),e=Object(o.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"_1-浏览器垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器垃圾回收机制"}},[v._v("#")]),v._v(" 1. 浏览器垃圾回收机制")]),v._v(" "),t("p",[v._v("常见自动垃圾回收策略：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("标记清除")])]),v._v(" "),t("p",[v._v("过程：先将进入环境的变量都打上标记，然后消除处于执行上下文的变量上的标记，最后回收内存中被标记的变量")]),v._v(" "),t("p",[v._v("缺点：多次回收操作后会产生大量的"),t("strong",[v._v("内存碎片")]),v._v("，会造成因为没有足够的连续内存而分配失败")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("引用计数")])]),v._v(" "),t("p",[v._v("统计指向统计对象的引用数目，若引用数为0则回收对象")]),v._v(" "),t("p",[v._v("缺点：若对象存在循环引用，则对象不会被回收，容易造成内存泄漏")])])]),v._v(" "),t("p",[t("strong",[v._v("V8")]),v._v(" JavaScript的垃圾回收策略：")]),v._v(" "),t("p",[v._v("​    JavaScript中的垃圾回收用到了"),t("strong",[v._v("分代收集")]),v._v("的思想，引擎将堆空间分为"),t("strong",[v._v("新生代")]),v._v("和"),t("strong",[v._v("老生代")]),v._v("，对"),t("strong",[v._v("新生代采用复制算法")]),v._v("，"),t("strong",[v._v("老生代采用标记-压缩算法")])]),v._v(" "),t("p",[t("code",[v._v("分代收集")]),v._v("：内存中大多数对象的生命周期很短，而一些一直存活的对象通常会存在很久，"),t("strong",[v._v("对象的生存时间两极分化")])]),v._v(" "),t("p",[t("code",[v._v("新生代")]),v._v("：存放生存时间短的对象，大多数新创建的小对象都会被分配到该区域，该区域的垃圾回收会比较频繁")]),v._v(" "),t("p",[t("code",[v._v("复制算法")]),v._v("：将整个空间平均分成"),t("code",[v._v("from")]),v._v("和"),t("code",[v._v("to")]),v._v("两部分，先在"),t("code",[v._v("from")]),v._v("空间进行内存分配，当空间被占满时将标记的活动对象赋值到"),t("code",[v._v("to")]),v._v("空间，复制完成后将"),t("code",[v._v("from")]),v._v("和"),t("code",[v._v("to")]),v._v("空间互换")]),v._v(" "),t("p",[v._v("缺点：复制操作需要时间成本，且将空间二等分使得可用内存空间减少了一半")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041456520.webp",alt:"图片"}})]),v._v(" "),t("p",[t("code",[v._v("老生代")]),v._v("：存放生存时间长的对象和大的对象，新生代中经过两次垃圾回收后仍然存活的对象")]),v._v(" "),t("p",[t("code",[v._v("标记-压缩算法")]),v._v("：结合了标记-清除法和复制算法的优点，将所有活动对象移到内存的一端，直接清理掉边界意外的内存释放连续空间；避免了内存碎片问题和可用空间减半的问题，但是整理操作比较耗时")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202206041456522.webp",alt:"图片"}})]),v._v(" "),t("h3",{attrs:{id:"_2-内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存泄漏"}},[v._v("#")]),v._v(" 2. 内存泄漏")]),v._v(" "),t("blockquote",[t("p",[v._v("内存泄漏是指已不再使用的内存未能释放，从而造成性能上的浪费")])]),v._v(" "),t("ul",[t("li",[v._v("计时器或回调函数：如vue中mount或create生命周期中创建的setTimeout在beforeDestory中未能被释放，或事件监听addEventListener、自定义事件event.$on")]),v._v(" "),t("li",[v._v("不合理的使用闭包：过度地使用闭包，闭包会保存对外层作用域中变量的引用，从而不会释放")]),v._v(" "),t("li",[v._v("意外的全局变量: 全局变量不会被垃圾回收，所以太多的全局变量会造成内存泄漏")]),v._v(" "),t("li",[v._v("DOM泄漏：对DOM的引用没有被清理，即使调用removeChild移除DOM，它仍然存在于内存中")]),v._v(" "),t("li",[v._v("循环引用")])])])}),[],!1,null,null,null);_.default=e.exports}}]);