(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{621:function(t,a,e){"use strict";e.r(a);var s=e(11),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_1-mqsql基于innodb存储-引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-mqsql基于innodb存储-引擎"}},[t._v("#")]),t._v(" 1. Mqsql基于InnoDB存储 引擎")]),t._v(" "),e("h3",{attrs:{id:"_2-mysql表的逻辑结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql表的逻辑结构"}},[t._v("#")]),t._v(" 2. Mysql表的逻辑结构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271152966.png",alt:"image-20221127115247816"}})]),t._v(" "),e("ul",[e("li",[t._v("TableSpace即表的逻辑存储结构，分为Leaf node segment、Non-Leaf node segment、Rollback segement三个"),e("code",[t._v("段")]),t._v("来存储。Leaf node segment存储"),e("code",[t._v("记录")]),t._v("、Non-Lead node segment存储"),e("code",[t._v("索引")]),t._v("，Rollback sement存储"),e("code",[t._v("回滚事务")])]),t._v(" "),e("li",[t._v("每一个Segment中有若干个Extent、Page， Extent可以理解为"),e("code",[t._v("区")]),t._v("；当数据库要增加存储空间时，就会增加Extent(1MB)；每个Extent由64个Page(16KB)组成; 在Segment中间插入了一些零碎的Page, 用来存储小数据量。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271206606.png",alt:"image-20221127120617549"}})]),t._v(" "),e("ul",[e("li",[t._v("Page中的主键按顺序存储，并且按照记录的插入循序排列成一个单链表")]),t._v(" "),e("li",[t._v("Page Directory中存储主键到数据地址的映射，在查询时通过二分法查询")])]),t._v(" "),e("h3",{attrs:{id:"_3-innodb的索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-innodb的索引"}},[t._v("#")]),t._v(" 3. InnoDB的索引")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271217727.png",alt:"image-20221127121759663"}})]),t._v(" "),e("ul",[e("li",[t._v("索引采用B+树实现，是一颗平衡的n叉树")]),t._v(" "),e("li",[t._v("B+树的根节点对应TableSpace中的Non-Leaf node segment, 叶子节点层对应Leaf node segment。n个子节点每个对应一个Page。")]),t._v(" "),e("li",[t._v("顺序插入是最高效的方式，在中间页插入记录可能导致叶子节点的分裂")]),t._v(" "),e("li",[t._v("删除数据可能会造成树结构的改变（叶子节点合并、非叶子节点改变），所以一般逻辑删除而非物理删除")])]),t._v(" "),e("h3",{attrs:{id:"_4-innodb的事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-innodb的事务"}},[t._v("#")]),t._v(" 4. InnoDB的事务")]),t._v(" "),e("h4",{attrs:{id:"_4-1-事务的acid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-事务的acid"}},[t._v("#")]),t._v(" 4.1 事务的ACID")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271429627.png",alt:"image-20221127142935522"}})]),t._v(" "),e("h4",{attrs:{id:"_4-2-事务的隔离级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-事务的隔离级别"}},[t._v("#")]),t._v(" 4.2 事务的隔离级别")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271436895.png",alt:"image-20221127143640845"}})]),t._v(" "),e("p",[t._v("MySQL默认采用REPEATABLE READ级别，通过加锁的方式实现（读时采用共享锁，写时采用排他锁）。在REPEATABLE READ中：")]),t._v(" "),e("ul",[e("li",[t._v("在同一个事务中，同样的查询结果是不变的。Mysql通过"),e("code",[t._v("快照")]),t._v("的方式实现。")]),t._v(" "),e("li",[t._v("如果两个事务同时对同一条记录操作，如果其中一个事务进行写操作，那么另一个事务再执行写操作会被阻塞。")])]),t._v(" "),e("h4",{attrs:{id:"_4-3-rollback-segment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-rollback-segment"}},[t._v("#")]),t._v(" 4.3 Rollback segment")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://picture-1305610595.cos.ap-guangzhou.myqcloud.com/202211271447892.png",alt:"image-20221127144755837"}})]),t._v(" "),e("p",[t._v("DB_TRX_ID为事务ID， DB_ROLL_PTR指向修改的事务")])])}),[],!1,null,null,null);a.default=n.exports}}]);